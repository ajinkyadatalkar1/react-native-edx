JavaScript Notes:
----------------------------------------------------------------------------------------------------
1) Semicolon is not compulsary at the end.
2) You can store function calls in an array and call them as:
	-Example:
		var items = ["toys",42,hello()];
	-You can store data of multiple types in a single array. And you can retrive that data as
	follows:
		items[0]
		items[1]
		items[2]()
	-Here the last line "items[2]()" will execute the function "hello()".

----------------------------------------------------------------------------------------------------
Difference between LET and VAR

VAR: 
<script>
function discountPrices (prices, discount) {
  let discounted = []

  for (var i = 0; i < prices.length; i++) {
    var discountedPrice = prices[i] * (1 - discount)
    var finalPrice = Math.round(discountedPrice * 100) / 100
    discounted.push(finalPrice)
  }

  console.log(i) // 3
  console.log(discountedPrice) // 150
  console.log(finalPrice) // 150

  return discounted
}

discountPrices([100, 200, 300], .5)
</script>

OUTPUT:
3
150
150


LET:
<script>
function discountPrices (prices, discount) {
  let discounted = []

  for (let i = 0; i < prices.length; i++) {
    let discountedPrice = prices[i] * (1 - discount)
    let finalPrice = Math.round(discountedPrice * 100) / 100
    discounted.push(finalPrice)
  }

  console.log(i) // 3
  console.log(discountedPrice) // 150
  console.log(finalPrice) // 150

  return discounted
}

discountPrices([100, 200, 300], .5)
</script>

OUTPUT:
ReferenceError: i is not defined

Explaination:

The main difference between var and let is that instead of being function scoped, let is block scoped.
So in the above examples the variables i, discountedPrice and finalPrice are available outside the for
loop only if they are declared as "var" and not as "let".

In the above examples the variables declared as "var" are available inside the functions and not globally.

VAR VS LET
VAR: 
1) Function scoped
2) Undefined when accessing a variable before it's declared

LET:
1) Block scoped
2) ReferenceError when accessing a variable before it's declared

----------------------------------------------------------------------------------------------------

Difference between CONST and LET

CONST is same as LET except for the fact that when you declare a variable as CONST, it cannot be reassigned.

Example:
let name = 'Tyler'
const handle = 'tylermcginnis'

name = 'Tyler McGinnis' // no error on reassignment
handle = '@tylermcginnis' // ‚ùå TypeError: Assignment to constant variable.

LET vs CONST
LET:
1) Block scoped
2) ReferenceError when accessing a variable before it's declared

CONST:
1) block scoped
2) ReferenceError when accessing a variable before it's declared
3) Can't be reassigned

----------------------------------------------------------------------------------------------------

HOISTING:

In JavaScript, a variable can be declared after it has been used. This is called hoisting.
Example 1:

<script>
x=5
console.log(x)
var x;
</script>

Output: 5

Example 2:

<script>
var x = 5; // Initialize x
var y;   // Declare y
console.log(x + " " + y);
y = 7;
</script>

Output:
5 undefined

----------------------------------------------------------------------------------------------------

PRIMITIVE DATA TYPES IN JAVASCRIPT:
1) bool
2) Number
3) String
4) Null
5) undefined
6) symbol

Everything except for the above are object.
Objects, Arrays, Functions, etc all fall under object or we can say that all are objects.

Primitive data types in javascript are immutable. That means everytime we change the value, the whole
variable is recreated. Whereas objects are mutable, that means the values hold by an object can be 
changed and recreated.

SYNTAX for creating objects:
const o = new Object() // will create an object
const o2 = {} // will also create an object of name o2
const o3 = {fname: 'ajinkya', lname: "datalkar", numbers: {age: 26, phone: 5516895418} // will also create an object with nested object


Remeber that objects are mutable and they can be used to store data efficiently.
Example: (Declare and retrive data from the object)

const o = new Object()
o.firstName = 'Jordan'
o.lastName = 'Hayashi'
o.isTeaching = true
o.greet = function() { console.log('Hello!') }

console.log(JSON.stringify(o)) // PRINT OUT THE WHOLE OBJECT

const o2 = {}
o2['firstName'] = 'Jordan'
const a = 'lastName'
o2[a] = 'Hayashi'

const o3 = {
  firstName: 'Jordan',
  lastName: 'Hayashi',
  greet: function() {
    console.log('hi')
  },
  address: {
    street: "Main st.",
    number: '111'
  }
}

console.log(o3.firstName) // PRINT OUT ONLY THE FIRSTNAME
console.log(o3.address.street) // PRINT OUT AN ELEMENT FROM NESTED OBJECT
console.log(o3.1) // Doesnt work will return error (key cannot be a number)
console.log(o3[1]) // PRINT OUT ONLY THE FIRSTNAME (will typecast int 1 to string 1)
console.log(o3["1"]) // PRINT OUT ONLY THE FIRSTNAME 

Explaination:
1) Object "keys" should be in string format, therefore when you try to retrive an object like this:
   "o3.1", it returns an error, because the "1" is an integer. When you write as "o3[1]" or "o3['1']"
   "1" is converted to string. Anything inside square brackets is converted to string.

2) Remember that the data inside the objects is stored in JSON format.

----------------------------------------------------------------------------------------------------

Object Mutation:

const o = {
  a: 'a',
  b: 'b',
  obj: {
    key: 'key',
  },
}

const o2 = o

o2.a = 'new value'

// o and o2 reference the same object (call by referance, if you change value in o2, value in o will also change)
// Here o and o2 both have referance to same memory location, so chaning o will also cause o2 to change
console.log(o.a)

// this shallow-copies o into o3
// this is same as o and o2, we just use assign function to create it, both works on call by referance and
// changing o3 will also change o
const o3 = Object.assign({}, o)


// deep copy
// here we create a completely new copy which refers to a different memory location and changing one wont affect the other

function deepCopy(obj) {
  // check if vals are objects
  // if so, copy that object (deep copy)
  // else return the value
  const keys = Object.keys(obj)

  const newObject = {}

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    if (typeof obj[key] === 'object') {
      newObject[key] = deepCopy(obj[key])
    } else {
      newObject[key] = obj[key]
    }
  }

  return newObject
}

const o4 = deepCopy(o)

o.obj.key = 'new key!'
console.log(o4.obj.key)
// changing values in o4 wont affect o1, o2 or o3.
----------------------------------------------------------------------------------------------------

1) Arrays work the same way as objects.
2) In termianl, to check the methods available for a data type, you can type in the chrome terminal:
"arr.__proto__", this will return the list of methods available for the array of name "arr"
3) If an array and an object is given same name, say "arr", whenever arr is invoked array will be 
given precedence over the object.

----------------------------------------------------------------------------------------------------

PROTOTYPAL INHERITANCE

1) Most primitive data types have object wrappers
	String()
	Number()
	Boolean()
	Object()
	Symbol()

 For example:
	42.toString() // will return error
 However:
	const x=42;
	x.toString // will output the number enclosed in double quotes like: "42"

2) In google chromes developer console you can try "x.__proto__" this will give you a list of all the
   available methods for the Number object wrapper, like the "toString()" method.

3) Javascript will automatically box (wrap) the primitive values so that you can access methods needed to
   modify the data type and other factors of the variable.

----------------------------------------------------------------------------------------------------

HOISTING continued:
In javascript, the variables are considered as lexative and non lexative.

1) Variables declared using "var", functions and objects are all lexical. These are hoisted at the 
   beginning of the script. Incase of lexical scoping, the variable is hoisted at the top but its value is
   not initialized.

   Example:
	console.log(x); // will return undefined (variable is hoisted but value isnt initialized)
	var x=5;
	console.log(x); // will return 5
	
 Lexical variables stay in the memory until the end of the program or until the end of the functions
 in which they are declared.

2) Let and Const are non lexical variables, they are not hoisted at the beginning of the script, therefore:
	Example:
	console.log(y); // undefined referance error (program won't continue after this point)
	const y = 5;
	console.log(y);

3) What happens when you call a method before its declared?
	Example:
	hello("ajinkya"); // Will display "hello ajinkya" because functions are hoisted as well as initialized at the beginning.
	function hello(name){
		console.log("Hello" + name);
	}

4) What if a function is declared inside a const object?
	Example:
	a[0]; // will return an error and program will stop execution
	const a = { function() {console.log("hello")}}

	However:
	const a = { function() {console.log("hello")}}
	a[0]; // will output "hello" to the console

----------------------------------------------------------------------------------------------------

Remember, that even if objects are declared as const, elements can still be pushed, poped or replaced.
This is because, objects make use of the call by referance method.
Example:
	const a = {};
	a.firstName = "ajinkya"; // this will work
	a.lastName = "datalkar"; // this will also work

However:
	const a = "hello";
	a="world"; // this will caise an error
